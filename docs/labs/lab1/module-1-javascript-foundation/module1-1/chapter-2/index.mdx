# Chapter 2: Data Types

# บทที่ 2: Data Types — Primitive vs Reference

ใน JavaScript เราเจอข้อมูลหลายรูปแบบ ทั้งตัวเลข ตัวอักษร และโครงสร้างที่ซับซ้อนกว่า การเข้าใจประเภทข้อมูล (Data types) จะช่วยให้จัดการค่าต่าง ๆ ได้ถูกต้อง แก้บั๊กง่ายขึ้น และเลือกใช้หน่วยความจำอย่างมีประสิทธิภาพ

---

## แบ่งเป็น 2 กลุ่มใหญ่
- Primitive: `string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`
- Reference: `object`, `array`, `function`, `Date`, `Map`, ฯลฯ

---

## Primitive type (เก็บค่าเป็นตัว ๆ)

```js
const title = "KCode";      // string
const price = 49.5;         // number (มีทั้ง int/float)
const isOpen = true;        // boolean
const nothing = null;       // null (ตั้งใจไม่มีค่า)
let notSet;                 // undefined (ยังไม่ได้กำหนด)
const token = Symbol("id"); // symbol (คีย์เฉพาะตัว)
const big = 10n ** 20n;     // bigint (จำนวนเต็มใหญ่มาก)
```

- Primitive ถูก copy by value — เวลานำไปเก็บในตัวแปรใหม่จะได้สำเนาใหม่

```js
let a = 5;
let b = a;
a = 10;
console.log(b); // 5
```

---

## Reference type (อ้างอิงที่อยู่ในหน่วยความจำ)

```js
const user = { name: "Alice", age: 25 }; // object
const skills = ["JS", "Node"];           // array
function greet() {                       // function
  console.log("hi");
}
```

- Reference ถูก copy by reference — ตัวแปรใหม่ชี้ไปหาก้อนข้อมูลเดียวกัน

```js
const user1 = { name: "Alice" };
const user2 = user1;
user1.name = "Bob";
console.log(user2.name); // "Bob"
```

---

## เช็คชนิดข้อมูลด้วย `typeof`

```js
typeof "KCode"; // "string"
typeof 7;       // "number"
typeof true;    // "boolean"
typeof {};      // "object"
typeof [];      // "object"   (array ก็เป็น object)
typeof null;    // "object"   (quirk ของ JS)
typeof undefined; // "undefined"
typeof (() => {}); // "function"
```

- ถ้าอยากแยก Array ใช้ `Array.isArray(skills)` จะได้ `true`

---

## Null vs Undefined
- `undefined`: ค่าเริ่มต้นเมื่อยังไม่ได้กำหนด
- `null`: ให้เองเพื่อบอกว่า "ไม่มี" อย่างตั้งใจ

```js
let a;          // undefined
let b = null;   // null
```

---

## Truthy / Falsy

ค่าที่ถูกแปลงเป็น `false`: `false`, `0`, `""` (สตริงว่าง), `null`, `undefined`, `NaN`

```js
if ("") {
  // ไม่เข้ามา เพราะ "" เป็น falsy
}
```

---

## แปลงชนิดข้อมูล (Type Coercion)

```js
const num = Number("42");      // 42 (number)
const text = String(123);      // "123"
const flag = Boolean("hello"); // true

// อัตโนมัติ (implicit)
console.log("5" + 2);  // "52" (ถ้าเป็น + จะต่อสตริง)
console.log("5" * 2);  // 10   (ตัวคูณบังคับเป็น number)
```

หลีกเลี่ยงการใช้ `==` เพราะแปลงชนิดให้อัตโนมัติ ใช้ `===` ให้เปรียบเทียบทั้งค่าและชนิด

---

## ตัวอย่าง: ระบบตะกร้าสินค้า

```js
const cart = [
  { name: "Latte", price: 55, qty: 1 },
  { name: "Mocha", price: 65, qty: 2 }
];

let totalQty = 0;      // number (primitive)
let summaryText = "";  // string (primitive)

for (const item of cart) {
  totalQty += item.qty; // number + number
}

summaryText = `มีสินค้า ${totalQty} รายการ`;

console.log(summaryText);
console.log(cart); // array ของ object (reference)
```

---

# Lab — สำรวจ Data Types
1) สร้าง object `product` มีชื่อ ราคา และสถานะเปิดขาย (boolean)  
2) เพิ่ม array `tags` เป็นคำอธิบายสินค้า  
3) คำนวณส่วนลด: สร้างตัวแปร `discountedPrice` เป็น number  
4) ใช้ `typeof` ตรวจทุกตัวแปรและ console.log ผลลัพธ์  
5) ทดลองเปลี่ยน `tags` เดิมกับสำเนาอีกตัวเพื่อสังเกตผล copy by reference

<details>
<summary>เฉลย</summary>

```js
const product = {
  name: "Latte",
  price: 55,
  isOpen: true
};

const tags = ["coffee", "milk"];

const discountedPrice = product.price * 0.9;

console.log(typeof product);          // "object"
console.log(typeof product.price);    // "number"
console.log(typeof product.isOpen);   // "boolean"
console.log(typeof discountedPrice);  // "number"
console.log(Array.isArray(tags));     // true

const tagsCopy = [...tags]; // สำเนาใหม่
tagsCopy.push("promo");

console.log(tags);     // ["coffee", "milk"]
console.log(tagsCopy); // ["coffee", "milk", "promo"]
```

</details>
