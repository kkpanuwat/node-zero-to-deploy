# Chapter 6: Lab — Web Server ร้านอาหาร

## โจทย์หลัก
- สร้างเซิร์ฟเวอร์ด้วย `http` module (หรือ express ถ้าถนัด) รองรับเส้นทาง:
  - `GET /` → `"Welcome to My Café API"`
  - `GET /about`
  - `GET /status` → ส่ง uptime, memory usage
  - `GET /menu` → ส่ง JSON เมนู (ใช้ข้อมูลจาก Module 1)
  - `GET /menu/:name` → ส่งข้อมูลเมนูเดียว (ค้นจากชื่อแบบ case-insensitive)
  - `GET /search?q=` → ค้นหาเมนูโดยชื่อบางส่วน
- ตั้ง `Content-Type` ให้เหมาะสม
- log `method`, `url`, timestamp ทุกครั้ง พร้อมสถานะตอบกลับ

## โครงสร้างข้อมูล
```js
const menu = [
  { name: "Latte", price: 55 },
  { name: "Mocha", price: 65 },
  { name: "Ame", price: 45 }
];
```

## ขั้นตอนทำตาม (แนะนำสำหรับคลาส 8 ชม.)

### 1) เตรียมโปรเจกต์ + สคริปต์
- `npm init -y`
- ติดตั้ง `nodemon --save-dev`
- ตั้ง script ใน `package.json`:
```json
{
  "scripts": {
    "dev": "nodemon server.js",
    "start": "node server.js"
  }
}
```

### 2) สร้าง server.js เริ่มต้น
```js
import http from "http";

const menu = [ /* ...เมนูจากด้านบน... */ ];

const server = http.createServer((req, res) => {
  console.log(`${new Date().toISOString()} ${req.method} ${req.url}`);
  // ใส่ routing ที่ด้านล่าง
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`Server running at http://localhost:${PORT}`);
});
```

### 3) ฟังก์ชันสำคัญที่ควรรู้
- `res.writeHead(statusCode, headers)` ตั้ง status + header
- `res.end(body)` ส่งผลลัพธ์กลับ
- `JSON.stringify(data, null, 2)` แปลง object/array เป็น JSON อ่านง่าย
- `process.uptime()` เวลาที่ server ทำงาน (วินาที)
- `process.memoryUsage()` ใช้ดูหน่วยความจำ สำหรับ `/status`
- (เสริม) `setTimeout` / `setInterval` ลอง log เพื่อดู Event Loop ทำงาน

### 4) Routing (ตัวอย่าง)
```js
const sendJSON = (res, data, status = 200) => {
  res.writeHead(status, { "Content-Type": "application/json" });
  res.end(JSON.stringify(data));
};

const sendText = (res, text, status = 200) => {
  res.writeHead(status, { "Content-Type": "text/plain" });
  res.end(text);
};

const routes = {
  "/": () => (res) => sendText(res, "Welcome to My Café API"),
  "/about": () => (res) => sendText(res, "About our café"),
  "/status": () => (res) =>
    sendJSON(res, {
      status: "ok",
      uptime: process.uptime().toFixed(2),
      memory: process.memoryUsage().rss
    }),
  "/menu": () => (res) => sendJSON(res, menu)
};
```

### 5) จัดการเส้นทางแบบไดนามิก
```js
const handleRequest = (req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`);
  const path = url.pathname;
  const q = url.searchParams.get("q");

  if (req.method === "GET" && routes[path]) {
    return routes[path]()(res);
  }

  // /menu/:name
  if (req.method === "GET" && path.startsWith("/menu/")) {
    const name = decodeURIComponent(path.replace("/menu/", "")).toLowerCase();
    const item = menu.find((m) => m.name.toLowerCase() === name);
    if (!item) return sendJSON(res, { error: "Not found" }, 404);
    return sendJSON(res, item);
  }

  // /search?q=
  if (req.method === "GET" && path === "/search") {
    const keyword = (q || "").toLowerCase();
    const result = menu.filter((m) => m.name.toLowerCase().includes(keyword));
    return sendJSON(res, result);
  }

  sendText(res, "Not found", 404);
};
```

แล้วใน `createServer`:
```js
const server = http.createServer((req, res) => {
  console.log(`${new Date().toISOString()} ${req.method} ${req.url}`);
  handleRequest(req, res);
});
```

### 6) เพิ่มการจัดรูปแบบ log
```js
const log = (req, status) => {
  console.log(
    `${new Date().toISOString()} ${req.method} ${req.url} -> ${status}`
  );
};
// เรียก log ก่อน/หลังส่ง response ก็ได้ (ปรับฟังก์ชัน sendJSON/sendText ให้ log)
```

### 7) ทดสอบ
- ใช้ browser/Postman/curl:
  - `/`, `/about`, `/status`, `/menu`, `/menu/latte`, `/search?q=mo`
- ทดลอง Content-Type ผิด แล้วดูผลเพื่อเน้นความสำคัญของ header

### 8) งานเสริม (ถ้ามีเวลา)
- เพิ่ม `/health` ส่ง `{ ok: true, time: ... }`
- เพิ่ม query `?limit=` ใน `/menu` เพื่อจำกัดจำนวน
- ทำเวอร์ชัน express สั้น ๆ เพื่อเปรียบเทียบโค้ด (เตรียม Module 3)

## เป้าหมาย
- ใช้ `http` module ได้จริง พร้อม log และ header ที่ถูกต้อง
- เข้าใจ event loop/non-blocking ผ่านการลอง setTimeout/readFile (เสริม)
- มี server แรกที่ตอบหลาย route และผูกข้อมูลเมนูจาก Module 1
