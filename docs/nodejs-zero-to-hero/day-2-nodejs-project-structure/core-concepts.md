---
id: day-2-core-concepts
title: 'Day 2: Core Concepts'
sidebar_label: 'Core Concepts'
description: ทำความเข้าใจ Node.js, npm, การวางโครงสร้างโปรเจกต์, และการสร้าง HTTP Server พื้นฐาน
---

# Part 1 — Core Concepts: ปูพื้นฐานสู่การเป็นนักพัฒนา Node.js

## ทำไมเราต้องใส่ใจกับ "โครงสร้างโปรเจกต์"?

<p align="center">
  <img src={require('../../../static/img/day-2/day2-design-structure.png').default} alt="Day 1 Hero" style={{maxWidth: '600px', width: '80%'}} />
</p>

ในชีวิตจริง โปรเจกต์ไม่ได้มีแค่ไฟล์เดียวแล้วจบ แต่ประกอบด้วยส่วนต่างๆ มากมาย:
- โค้ดสำหรับ **"รันเซิร์ฟเวอร์"** (จุดเริ่มต้นของโปรแกรม)
- โค้ดสำหรับ **"จัดการข้อมูล"** (เช่น การเชื่อมต่อฐานข้อมูล)
- โค้ดสำหรับ **"ฟังก์ชันเสริม"** ที่ใช้ซ้ำๆ (Utilities)
- ไฟล์ **"ตั้งค่า"** ต่างๆ ของโปรเจกต์ (Configuration)

Day 2 จึงเน้นที่การ **"จัดระเบียบ"** โปรเจกต์ให้พร้อมเติบโต และ **"สร้างมาตรฐาน"** ให้ทีมทำงานร่วมกันได้ง่ายผ่าน `npm scripts` ก่อนที่เราจะไปสร้าง API ที่ซับซ้อนกันต่อ

---

## Node.js: เมื่อ JavaScript ออกมาวิ่งนอก Browser

**Node.js** คือเครื่องมือที่ทำให้เราสามารถรันโค้ด JavaScript ที่ไหนก็ได้ ไม่ว่าจะเป็นบนเซิร์ฟเวอร์, ใน Terminal, หรือบนคอมพิวเตอร์ของเรา

**สิ่งที่แตกต่างจาก JavaScript ใน Browser:**
- **Browser JS**: มีเครื่องมือสำหรับจัดการหน้าเว็บ เช่น `document`, `window`, และ DOM เพื่อสร้าง UI ที่ผู้ใช้มองเห็น
- **Node.js**: ไม่มีหน้าเว็บให้ยุ่งเกี่ยว แต่มีเครื่องมือสำหรับทำงานฝั่งเซิร์ฟเวอร์ เช่น `fs` (อ่าน/เขียนไฟล์), `http` (สร้างเซิร์ฟเวอร์), `process` (เข้าถึงค่า Environment)

**หัวใจสำคัญ: Event Loop**
ลองจินตนาการว่า Node.js คือพนักงานรับออเดอร์ที่เก่งมากๆ:
- เมื่อมีงานเข้ามา (Request), Node.js จะรับมาแล้วเริ่มทำทันที
- ถ้าเจองานที่ต้องรอ (เช่น อ่านไฟล์, เรียกข้อมูลจาก Database), มันจะไม่ยืนรอเฉยๆ แต่จะส่งงานนั้นไปให้ "ผู้ช่วย" แล้วหันไปรับงานอื่นต่อ
- เมื่องานที่รอเสร็จ, "ผู้ช่วย" จะนำผลลัพธ์กลับมาส่งให้
- วิธีนี้ทำให้ Node.js จัดการหลายๆ คำขอได้พร้อมกันโดยไม่ติดขัด (Non-blocking)

**สรุป:** วันนี้เรากำลังสร้าง **HTTP Server** ที่รันด้วย Node.js โดยมี Browser หรือ `curl` เป็น Client ที่ส่งคำขอเข้ามา และเราจะตอบกลับเป็นข้อมูล JSON ซึ่งเป็นพื้นฐานของการสร้าง API นั่นเอง

---

## npm และ `package.json`: กล่องเครื่องมือและบัตรประชาชนของโปรเจกต์

- **`package.json`**: เปรียบเสมือน "บัตรประชาชนของโปรเจกต์" ที่บอกทุกอย่างเกี่ยวกับโปรเจกต์ของเรา: ชื่อ, เวอร์ชั่น, และที่สำคัญคือรายชื่อเครื่องมือ (Dependencies) ที่เรายืมมาใช้
- **`npm install <package-name>`**: คำสั่งสำหรับติดตั้ง "เครื่องมือ" หรือไลบรารีจากชุมชนนักพัฒนาทั่วโลก
- **`npm run <script-name>`**: คำสั่งสำหรับรันสคริปต์ที่เราเขียนทางลัดไว้ ช่วยให้เราไม่ต้องพิมพ์คำสั่งยาวๆ ซ้ำไปซ้ำมา

**dependencies vs devDependencies: ของที่ใช้จริง vs ของที่ใช้ตอนสร้าง**
- **`dependencies`**: คือไลบรารีที่จำเป็นสำหรับให้โปรแกรม **"รันได้"** ในชีวิตจริง (Production) เช่น `express`
- **`devDependencies`**: คือเครื่องมือที่ช่วยเราตอน **"พัฒนา"** เท่านั้น ไม่ได้ถูกส่งไปใช้งานจริง เช่น `nodemon` (สำหรับรีสตาร์ทเซิร์ฟเวอร์อัตโนมัติ), `eslint` (สำหรับตรวจจับข้อผิดพลาดในโค้ด)

---

## Project Structure: จัดบ้านให้เป็นระเบียบ

เป้าหมายคือการ "แยกไฟล์ตามหน้าที่" เพื่อให้ง่ายต่อการแก้ไขและต่อยอดในอนาคต

**โครงสร้างพื้นฐานสำหรับวันนี้:**
```
library-system/
  package.json
  src/
    server-basic.js     # จุดเริ่มต้นของเซิร์ฟเวอร์
    data/
      books.js          # ข้อมูลจำลอง (ยังไม่ต่อ DB)
    utils/
      logger.js         # ฟังก์ชันเสริมที่ใช้ซ้ำๆ
```

**Pro-tip: โครงสร้างสำหรับโปรเจกต์ที่ใหญ่ขึ้น**
เมื่อโปรเจกต์เริ่มซับซ้อน เราอาจแบ่งโฟลเดอร์ละเอียดขึ้นอีก เช่น:
- `config/`: เก็บไฟล์ตั้งค่าต่างๆ
- `routes/`: จัดการเส้นทาง (URL) ของ API
- `handlers/` หรือ `controllers/`: โค้ดที่จัดการ Logic ของแต่ละ Request
- `repositories/`: ส่วนที่รับผิดชอบการคุยกับฐานข้อมูลโดยเฉพาะ

---

## Module System: `require` vs `import`

Node.js มีระบบการเรียกใช้ไฟล์ 2 แบบหลัก:
- **CommonJS (CJS)**: ใช้ `require()` และ `module.exports` (รูปแบบดั้งเดิมที่เจอบ่อย)
- **ES Modules (ESM)**: ใช้ `import` และ `export` (รูปแบบทันสมัย)

ในคอร์สนี้เราจะใช้ **CommonJS** เป็นหลักเพื่อความง่าย แต่สิ่งสำคัญคือ **"เลือกใช้แค่แบบเดียวในโปรเจกต์"** เพื่อป้องกันความสับสน

---

## Content-Type Header: บอก Client ว่าเรากำลังจะส่งอะไรไป

เมื่อเซิร์ฟเวอร์จะส่งข้อมูลกลับไปให้ Client (เช่น Browser), มันจำเป็นต้องบอกว่า "ข้อมูลที่กำลังจะส่งไปนี้ เป็นไฟล์ประเภทอะไร?" เพื่อให้ Client นำไปแสดงผลได้อย่างถูกต้อง สิ่งนี้เรียกว่า `Content-Type` ซึ่งเป็นส่วนหนึ่งของ HTTP Header

**`Content-Type` ที่พบบ่อย:**

*   **`text/html`**: สำหรับส่งหน้าเว็บ HTML ทั้งหน้า
    *   *ตัวอย่าง:* `<h1>สวัสดี</h1><p>นี่คือหน้าเว็บ</p>`
*   **`application/json`**: สำหรับส่งข้อมูลในรูปแบบ JSON ซึ่งเป็นที่นิยมมากในการสร้าง API
    *   *ตัวอย่าง:* `{"name": "หนังสือ", "price": 100}`
*   **`text/plain`**: สำหรับส่งข้อความธรรมดา ไม่มีรูปแบบ
    *   *ตัวอย่าง:* `Hello, world!`
*   **`image/jpeg`, `image/png`**: สำหรับส่งไฟล์รูปภาพ
*   **`application/xml`**: สำหรับส่งข้อมูลในรูปแบบ XML
*   **`application/pdf`**: สำหรับส่งไฟล์เอกสาร PDF

**ทำไมถึงสำคัญ?**
ถ้าเราส่งข้อมูล JSON แต่บอก `Content-Type` เป็น `text/html`, Browser อาจจะพยายามแสดงผลเป็นหน้าเว็บแล้วเพี้ยนไปเลย ในทางกลับกัน ถ้าเราตั้งค่า `Content-Type` ถูกต้อง, Browser หรือโปรแกรมที่เรียก API ก็จะรู้ทันทีว่าต้องจัดการกับข้อมูลนี้อย่างไร เช่น ถ้าเป็น `application/json` ก็จะนำไปประมวลผลเป็น Object ต่อได้เลย

ในการสร้างเซิร์ฟเวอร์ด้วย `http` module, เราจะใช้ `response.setHeader('Content-Type', 'application/json');` เพื่อกำหนดค่านี้ก่อนที่จะส่งข้อมูลกลับไป

---

## HTTP Module: สร้างเซิร์ฟเวอร์ตัวแรก

ก่อนจะไปใช้เฟรมเวิร์คอย่าง Express เรามาลองสร้างเซิร์ฟเวอร์ด้วยเครื่องมือพื้นฐานของ Node.js อย่าง `http` กันก่อน
- เราจะใช้ `http.createServer((req, res) => { ... })`
- **`req` (Request)**: คือ "จดหมาย" ที่ Client ส่งมา บอกเราว่าต้องการอะไร (เช่น `req.method`, `req.url`)
- **`res` (Response)**: คือ "คำตอบ" ที่เราจะส่งกลับไปให้ Client (เช่น `res.statusCode`, `res.end()`)

### ตัวอย่าง: เซิร์ฟเวอร์ที่ง่ายที่สุดในโลก

ลองมาสร้างเซิร์ฟเวอร์ตัวแรกกันจริงๆ เพื่อให้เห็นภาพชัดเจน

**ขั้นตอนการทำตาม:**

1.  สร้างไฟล์ใหม่ในโปรเจกต์ของคุณชื่อ `my-first-server.js`
2.  คัดลอกโค้ดด้านล่างนี้ไปวางในไฟล์:

    ```javascript
    // 1. เรียกใช้ http module ที่มีมากับ Node.js
    const http = require('http');

    // 2. สร้างเซิร์ฟเวอร์ โดยใส่ฟังก์ชันที่จะทำงานทุกครั้งเมื่อมี Request เข้ามา
    const server = http.createServer((request, response) => {
      console.log('มีคนส่ง Request เข้ามา!'); // แสดง log ใน terminal

      // 3. ตั้งค่าหัวกระดาษ (Header) เพื่อบอกว่าจะตอบกลับเป็นอะไร
      response.setHeader('Content-Type', 'application/json');
      response.statusCode = 200; // 200 OK

      // 4. เขียนเนื้อหาที่จะตอบกลับไป (ต้องเป็น String)
      const responseBody = {
        message: 'Hello from my first Node.js Server!'
      };
      response.end(JSON.stringify(responseBody)); // แปลง Object เป็น JSON String แล้วส่งกลับ
    });

    // 5. สั่งให้เซิร์ฟเวอร์เริ่มรอรับ Request ที่ Port 3000
    const port = 3000;
    server.listen(port, () => {
      console.log(`Server is listening on http://localhost:${port}`);
    });
    ```

3.  เปิด Terminal แล้วรันไฟล์นี้ด้วยคำสั่ง:
    ```bash
    node my-first-server.js
    ```
    คุณจะเห็นข้อความ `Server is listening on http://localhost:3000`

4.  เปิดเว็บเบราว์เซอร์ (เช่น Chrome, Firefox) แล้วเข้าไปที่ `http://localhost:3000`

**ผลลัพธ์:** คุณควรจะเห็นข้อความ JSON `{"message":"Hello from my first Node.js Server!"}` ปรากฏบนหน้าจอ และใน Terminal ที่รันโค้ดอยู่ ก็จะเห็นข้อความ `มีคนส่ง Request เข้ามา!`

นี่คือพื้นฐานที่สุดของการสร้างเว็บเซิร์ฟเวอร์ด้วย Node.js ครับ!

**สิ่งสำคัญที่ต้องรู้:**
- **404 Not Found**: Client ขอ URL ที่ไม่มีอยู่จริง
- **405 Method Not Allowed**: Client ขอ URL ที่มีอยู่ แต่ใช้ Method ผิด (เช่น ขอ `POST` ไปที่ URL ที่รับแค่ `GET`)

---

## Environment Variables (.env)

เราไม่ควร Hardcode ค่าที่อาจเปลี่ยนแปลงได้ (เช่น Port, รหัสผ่าน Database) ลงในโค้ดโดยตรง
- **วิธีปฏิบัติที่ดี**: ใช้ `process.env.PORT` เพื่ออ่านค่าจาก Environment
- **สำหรับการพัฒนา**: เรานิยมสร้างไฟล์ `.env` เพื่อเก็บค่าเหล่านี้ และใช้ไลบรารี `dotenv` เพื่อโหลดค่าเข้ามาในโปรเจกต์

---

## Persistence: ทำให้ข้อมูลไม่หายไป

ตอนนี้ข้อมูลหนังสือของเราอยู่ใน Memory ซึ่งหมายความว่าถ้าปิดเซิร์ฟเวอร์ ข้อมูลก็จะหายไปทั้งหมด
- **วิธีแก้แบบง่าย**: เราจะใช้ `fs` (File System) module เพื่อ **อ่าน/เขียน** ข้อมูลลงในไฟล์ JSON
- ทุกครั้งที่มีการเพิ่มข้อมูลใหม่ เราจะอัปเดตไฟล์ JSON นี้ ทำให้ข้อมูล "คงอยู่" (Persist) แม้จะรีสตาร์ทเซิร์ฟเวอร์

---

## Git Hygiene: ข้อปฏิบัติที่ดีในการใช้ Git

- **ห้าม Commit `node_modules/`**: โฟลเดอร์นี้มีขนาดใหญ่และสามารถสร้างขึ้นใหม่ได้เสมอด้วยคำสั่ง `npm install`
- **ห้าม Commit `.env`**: ไฟล์นี้อาจเก็บข้อมูลสำคัญ เช่น API Keys หรือรหัสผ่าน ควรสร้าง `.env.example` ไว้เป็นตัวอย่างให้ทีมแทน
- **Commit ให้มีความหมาย**: ตั้งชื่อ Commit ให้สื่อความหมาย เช่น `feat: add basic server setup` หรือ `fix: correct book data validation`

---

## Checklist ก่อนเริ่มลงมือทำ Lab

- [ ] คุณสามารถแยกได้ว่าไฟล์ไหนคือ "จุดเริ่มต้น" และไฟล์ไหนเป็น "ข้อมูล" หรือ "ฟังก์ชันเสริม"
- [ ] คุณเข้าใจว่า `scripts` ใน `package.json` มีไว้เพื่ออะไร
- [ ] คุณพอจะอธิบายได้ว่า `req` และ `res` ในการสร้างเซิร์ฟเวอร์คืออะไร

> **ทบทวนความเข้าใจ:** ลองอธิบายด้วยภาษาของคุณเองว่า "ถ้าในทีมมี 5 คน การมี `npm run dev` จะช่วยให้ทุกคนทำงานง่ายขึ้นได้อย่างไร?"
