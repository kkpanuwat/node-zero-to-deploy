---
id: day-2-core-concepts
title: 'Day 2: Core Concepts'
sidebar_label: 'Core Concepts'
description: ทำความเข้าใจ Node.js, npm, การวางโครงสร้างโปรเจกต์, และการสร้าง HTTP Server พื้นฐาน
---

# Part 1 — Core Concepts: ปูพื้นฐานสู่การเป็นนักพัฒนา Node.js

## ทำไมเราต้องใส่ใจกับ "โครงสร้างโปรเจกต์"?

ในชีวิตจริง โปรเจกต์ไม่ได้มีแค่ไฟล์เดียวแล้วจบ แต่ประกอบด้วยส่วนต่างๆ มากมาย:
- โค้ดสำหรับ **"รันเซิร์ฟเวอร์"** (จุดเริ่มต้นของโปรแกรม)
- โค้ดสำหรับ **"จัดการข้อมูล"** (เช่น การเชื่อมต่อฐานข้อมูล)
- โค้ดสำหรับ **"ฟังก์ชันเสริม"** ที่ใช้ซ้ำๆ (Utilities)
- ไฟล์ **"ตั้งค่า"** ต่างๆ ของโปรเจกต์ (Configuration)

Day 2 จึงเน้นที่การ **"จัดระเบียบ"** โปรเจกต์ให้พร้อมเติบโต และ **"สร้างมาตรฐาน"** ให้ทีมทำงานร่วมกันได้ง่ายผ่าน `npm scripts` ก่อนที่เราจะไปสร้าง API ที่ซับซ้อนกันต่อ

---

## Node.js: เมื่อ JavaScript ออกมาวิ่งนอก Browser

**Node.js** คือเครื่องมือที่ทำให้เราสามารถรันโค้ด JavaScript ที่ไหนก็ได้ ไม่ว่าจะเป็นบนเซิร์ฟเวอร์, ใน Terminal, หรือบนคอมพิวเตอร์ของเรา

**สิ่งที่แตกต่างจาก JavaScript ใน Browser:**
- **Browser JS**: มีเครื่องมือสำหรับจัดการหน้าเว็บ เช่น `document`, `window`, และ DOM เพื่อสร้าง UI ที่ผู้ใช้มองเห็น
- **Node.js**: ไม่มีหน้าเว็บให้ยุ่งเกี่ยว แต่มีเครื่องมือสำหรับทำงานฝั่งเซิร์ฟเวอร์ เช่น `fs` (อ่าน/เขียนไฟล์), `http` (สร้างเซิร์ฟเวอร์), `process` (เข้าถึงค่า Environment)

**หัวใจสำคัญ: Event Loop**
ลองจินตนาการว่า Node.js คือพนักงานรับออเดอร์ที่เก่งมากๆ:
- เมื่อมีงานเข้ามา (Request), Node.js จะรับมาแล้วเริ่มทำทันที
- ถ้าเจองานที่ต้องรอ (เช่น อ่านไฟล์, เรียกข้อมูลจาก Database), มันจะไม่ยืนรอเฉยๆ แต่จะส่งงานนั้นไปให้ "ผู้ช่วย" แล้วหันไปรับงานอื่นต่อ
- เมื่องานที่รอเสร็จ, "ผู้ช่วย" จะนำผลลัพธ์กลับมาส่งให้
- วิธีนี้ทำให้ Node.js จัดการหลายๆ คำขอได้พร้อมกันโดยไม่ติดขัด (Non-blocking)

**สรุป:** วันนี้เรากำลังสร้าง **HTTP Server** ที่รันด้วย Node.js โดยมี Browser หรือ `curl` เป็น Client ที่ส่งคำขอเข้ามา และเราจะตอบกลับเป็นข้อมูล JSON ซึ่งเป็นพื้นฐานของการสร้าง API นั่นเอง

---

## npm และ `package.json`: กล่องเครื่องมือและบัตรประชาชนของโปรเจกต์

- **`package.json`**: เปรียบเสมือน "บัตรประชาชนของโปรเจกต์" ที่บอกทุกอย่างเกี่ยวกับโปรเจกต์ของเรา: ชื่อ, เวอร์ชั่น, และที่สำคัญคือรายชื่อเครื่องมือ (Dependencies) ที่เรายืมมาใช้
- **`npm install <package-name>`**: คำสั่งสำหรับติดตั้ง "เครื่องมือ" หรือไลบรารีจากชุมชนนักพัฒนาทั่วโลก
- **`npm run <script-name>`**: คำสั่งสำหรับรันสคริปต์ที่เราเขียนทางลัดไว้ ช่วยให้เราไม่ต้องพิมพ์คำสั่งยาวๆ ซ้ำไปซ้ำมา

**dependencies vs devDependencies: ของที่ใช้จริง vs ของที่ใช้ตอนสร้าง**
- **`dependencies`**: คือไลบรารีที่จำเป็นสำหรับให้โปรแกรม **"รันได้"** ในชีวิตจริง (Production) เช่น `express`
- **`devDependencies`**: คือเครื่องมือที่ช่วยเราตอน **"พัฒนา"** เท่านั้น ไม่ได้ถูกส่งไปใช้งานจริง เช่น `nodemon` (สำหรับรีสตาร์ทเซิร์ฟเวอร์อัตโนมัติ), `eslint` (สำหรับตรวจจับข้อผิดพลาดในโค้ด)

---

## Project Structure: จัดบ้านให้เป็นระเบียบ

เป้าหมายคือการ "แยกไฟล์ตามหน้าที่" เพื่อให้ง่ายต่อการแก้ไขและต่อยอดในอนาคต

**โครงสร้างพื้นฐานสำหรับวันนี้:**
```
library-system/
  package.json
  src/
    server-basic.js     # จุดเริ่มต้นของเซิร์ฟเวอร์
    data/
      books.js          # แหล่งข้อมูลจำลอง (ยังไม่ต่อ DB)
    utils/
      logger.js         # ฟังก์ชันเสริมที่ใช้ซ้ำๆ
```

**Pro-tip: โครงสร้างสำหรับโปรเจกต์ที่ใหญ่ขึ้น**
เมื่อโปรเจกต์เริ่มซับซ้อน เราอาจแบ่งโฟลเดอร์ละเอียดขึ้นอีก เช่น:
- `config/`: เก็บไฟล์ตั้งค่าต่างๆ
- `routes/`: จัดการเส้นทาง (URL) ของ API
- `handlers/` หรือ `controllers/`: โค้ดที่จัดการ Logic ของแต่ละ Request
- `repositories/`: ส่วนที่รับผิดชอบการคุยกับฐานข้อมูลโดยเฉพาะ

---

## Module System: `require` vs `import`

Node.js มีระบบการเรียกใช้ไฟล์ 2 แบบหลัก:
- **CommonJS (CJS)**: ใช้ `require()` และ `module.exports` (รูปแบบดั้งเดิมที่เจอบ่อย)
- **ES Modules (ESM)**: ใช้ `import` และ `export` (รูปแบบทันสมัย)

ในคอร์สนี้เราจะใช้ **CommonJS** เป็นหลักเพื่อความง่าย แต่สิ่งสำคัญคือ **"เลือกใช้แค่แบบเดียวในโปรเจกต์"** เพื่อป้องกันความสับสน

---

## HTTP Module: สร้างเซิร์ฟเวอร์ตัวแรก

ก่อนจะไปใช้เฟรมเวิร์คอย่าง Express เรามาลองสร้างเซิร์ฟเวอร์ด้วยเครื่องมือพื้นฐานของ Node.js อย่าง `http` กันก่อน
- เราจะใช้ `http.createServer((req, res) => { ... })`
- **`req` (Request)**: คือ "จดหมาย" ที่ Client ส่งมา บอกเราว่าต้องการอะไร (เช่น `req.method`, `req.url`)
- **`res` (Response)**: คือ "คำตอบ" ที่เราจะส่งกลับไปให้ Client (เช่น `res.statusCode`, `res.end()`)

**สิ่งสำคัญที่ต้องรู้:**
- **404 Not Found**: Client ขอ URL ที่ไม่มีอยู่จริง
- **405 Method Not Allowed**: Client ขอ URL ที่มีอยู่ แต่ใช้ Method ผิด (เช่น ขอ `POST` ไปที่ URL ที่รับแค่ `GET`)

---

## Environment Variables (.env)

เราไม่ควร Hardcode ค่าที่อาจเปลี่ยนแปลงได้ (เช่น Port, รหัสผ่าน Database) ลงในโค้ดโดยตรง
- **วิธีปฏิบัติที่ดี**: ใช้ `process.env.PORT` เพื่ออ่านค่าจาก Environment
- **สำหรับการพัฒนา**: เรานิยมสร้างไฟล์ `.env` เพื่อเก็บค่าเหล่านี้ และใช้ไลบรารี `dotenv` เพื่อโหลดค่าเข้ามาในโปรเจกต์

---

## Persistence: ทำให้ข้อมูลไม่หายไป

ตอนนี้ข้อมูลหนังสือของเราอยู่ใน Memory ซึ่งหมายความว่าถ้าปิดเซิร์ฟเวอร์ ข้อมูลก็จะหายไปทั้งหมด
- **วิธีแก้แบบง่าย**: เราจะใช้ `fs` (File System) module เพื่อ **อ่าน/เขียน** ข้อมูลลงในไฟล์ JSON
- ทุกครั้งที่มีการเพิ่มข้อมูลใหม่ เราจะอัปเดตไฟล์ JSON นี้ ทำให้ข้อมูล "คงอยู่" (Persist) แม้จะรีสตาร์ทเซิร์ฟเวอร์

---

## Git Hygiene: ข้อปฏิบัติที่ดีในการใช้ Git

- **ห้าม Commit `node_modules/`**: โฟลเดอร์นี้มีขนาดใหญ่และสามารถสร้างขึ้นใหม่ได้เสมอด้วยคำสั่ง `npm install`
- **ห้าม Commit `.env`**: ไฟล์นี้อาจเก็บข้อมูลสำคัญ เช่น API Keys หรือรหัสผ่าน ควรสร้าง `.env.example` ไว้เป็นตัวอย่างให้ทีมแทน
- **Commit ให้มีความหมาย**: ตั้งชื่อ Commit ให้สื่อความหมาย เช่น `feat: add basic server setup` หรือ `fix: correct book data validation`

---

## Checklist ก่อนเริ่มลงมือทำ Lab

- [ ] คุณสามารถแยกได้ว่าไฟล์ไหนคือ "จุดเริ่มต้น" และไฟล์ไหนเป็น "ข้อมูล" หรือ "ฟังก์ชันเสริม"
- [ ] คุณเข้าใจว่า `scripts` ใน `package.json` มีไว้เพื่ออะไร
- [ ] คุณพอจะอธิบายได้ว่า `req` และ `res` ในการสร้างเซิร์ฟเวอร์คืออะไร

> **ทบทวนความเข้าใจ:** ลองอธิบายด้วยภาษาของคุณเองว่า "ถ้าในทีมมี 5 คน การมี `npm run dev` จะช่วยให้ทุกคนทำงานง่ายขึ้นได้อย่างไร?"
